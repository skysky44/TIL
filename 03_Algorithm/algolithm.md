# 알고리즘 1일차

## 알고리즘 공부

- 어려운 문제일수록 생각하는 시간 필요
- 개발자란? 문제해결을 하는 사람(기술을 좀 아는)
- 오랜 시간 고민했는데 풀리지 않을 때 타인의 답을 보면서 나에게 적합한 풀이를 찾는 것이 좋다.

- a라고 하는 문제를 다른 알고리즘으로 접근할 때가 있음(시간복잡도)
- 지금레벨: 코드 테크닉 x, 일반적인 접근 방법
- 90~95% : 문자열/리스트
- 5~10% : 딕셔너리, 세트

- 반복적으로 다른 사람 코드와 비교하다 보면 눈에 들어올 것

- 300 ~ 350문제 / solved.ac 참고

- 니클라우스 비르트 . 튜링상 수상
- 프로그램 == 데이터구조(저장) + 알고리즘(조작)

## 데이터 구조& 알고리즘

- Array (배열)
- Linked List (연결리스트)
- Hash (해시)
- Stack (스택)
- Queue (큐)
- Priority Queue (우선순위 큐)
- Heap(힙)
- Tree (트리)
- Graph (그래프)

- 기본 : 완전 탐색, 재귀, 시뮬레이션, 그리디
- 심화 : DFS, BFS, 백트래킹, 이진탐색, DP, 다익스트라, 크루스칼,프림

## 참고

- map 반복가능한 요소를 형변환 한다.
- 디버거 사용법 : number(변수)가 3일때 멈춤 가능/ 언제 어디에 찍어야 하느냐가 중요

# 알고리즘 2일차

## 시간복잡도(Time Complexity)

- 개인의 컴퓨터 환경에 따라 같은 알고리즘도 측정시간이 달라 객관적인 기준이 필요
- 알고리즘 내부에서 기본연산이 몇 번 일어나는지 확인

- 시간복잡도: (단순하게) `알고리즘의 수행 시간`을 의미

## 빅오(Big-O) 표기법

- 입력 n이 무한대로 커진다고 가정하고 최고차항만 남김(최악의 경우 고려)
- 정확한 수치보다는 증가율에 초점

![image](https://blog.kakaocdn.net/dn/s0pox/btq6Mbphdwr/s5K0D58hi5hiSrBuxmHHwk/img.png)

- O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < O(2^N)< O(N!)
- O(logN) : input size를 N이라고 했을때 `N*(1/2)^k = 1`(N을 1로 만들어주는 k값을 구하는 것) 그래서 `k = logN`

## 리스트(List)

### 배열(Array)

- 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조
- 인덱스를 통해 데이터에 빠른 접근
- 배열의 길이는 변경 불가능(길이 변경하고 싶으면 새로 생성)
- 데이터 타입은 고정

### 연결리스트(Linked List)

- 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조
- 맨 처음 노드부터 순차적 탐색
- 연결리스트의 길이는 자유롭게 변경 가능
- 다양한 데이터 타입 저장
- 데이터가 메모리에 연속적으로 저장되지 않음

### 파이썬의 리스트

- 인덱스로 접근(배열) + 가변 길이(연결리스트)

- 파이썬 리스트의 메서드

```python
.append()
.pop() # .pop(): 마지막 원소 pop / .pop(i): 인덱스i 원소 pop
.count()
.index() # 처음(왼쪽부터)으로 원소가 등장하는 인덱스 반환
.sort() # 오름차순 정렬(revese=True 옵션으로 내림차순 정렬)
.revese()
```

- 주의: .pop 하면 기존리스트가 바꾸기 때문에 for문 결과가 달라짐!

- 자주 쓰이는 리스트 관련 내장함수

```python
len()
sum()
max()
min()
sorted() : # 오름차순으로 새로운 리스트 반환(원본 리스트 변화 없음)
reversed() # 거꾸로 뒤집은 새로운 객체 반환(원본 리스트 변화 없음)
```

## 리스트 컴프리헨션(List Comprehension, 리스트 내포)

- 의미: 리스트를 생성하는 간단한 방법

```python
numbers=[]
for i in range(5):
    numbers.append(i)
```

- 간단하게

```python
numbers = [i for i in range(5)]
```

- if문으로 필터링도 가능

```python
odd numbers = [i for i range(10) if i % 2 ==1]
# [1, 3, 5, 7, 9]
```
